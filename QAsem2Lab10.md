# Функціональні інтерфейси та лямбда-вирази
### 1. В чому полягають відмінності, переваги та недоліки лямбда-виразів у порівнянні з анонімними класами?
  - ![лямбда-вирази та анонімні класи](https://github.com/nicknema/essentials-Of-Programming/blob/master/QAsem2Lab9.md#1-%D0%B2-%D1%87%D0%BE%D0%BC%D1%83-%D0%BF%D0%BE%D0%BB%D1%8F%D0%B3%D0%B0%D1%8E%D1%82%D1%8C-%D0%B2%D1%96%D0%B4%D0%BC%D1%96%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%96-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%B0%D0%B3%D0%B8-%D1%82%D0%B0-%D0%BD%D0%B5%D0%B4%D0%BE%D0%BB%D1%96%D0%BA%D0%B8-%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B2%D0%B8%D1%80%D0%B0%D0%B7%D1%96%D0%B2-%D1%83-%D0%BF%D0%BE%D1%80%D1%96%D0%B2%D0%BD%D1%8F%D0%BD%D0%BD%D1%96-%D0%B7-%D0%B0%D0%BD%D0%BE%D0%BD%D1%96%D0%BC%D0%BD%D0%B8%D0%BC%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D0%B0%D0%BC%D0%B8)
### 2. Що таке функціональний інтерфейс?
  -  ![Що таке функціональний інтерфейс?](https://github.com/nicknema/essentials-Of-Programming/blob/master/QAsem2Lab9.md#2-%D1%89%D0%BE-%D1%82%D0%B0%D0%BA%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D0%B9-%D1%96%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81)
### 3. Що таке статичні та дефолтні методи? Чим вони відрізняються від звичайних методів в інтерфейсах?
  - ![статичні та дефолтні методи](https://github.com/nicknema/essentials-Of-Programming/blob/master/QAsem2Lab9.md#3-%D1%89%D0%BE-%D1%82%D0%B0%D0%BA%D0%B5-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D1%96-%D1%82%D0%B0-%D0%B4%D0%B5%D1%84%D0%BE%D0%BB%D1%82%D0%BD%D1%96-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B8-%D1%87%D0%B8%D0%BC-%D0%B2%D0%BE%D0%BD%D0%B8-%D0%B2%D1%96%D0%B4%D1%80%D1%96%D0%B7%D0%BD%D1%8F%D1%8E%D1%82%D1%8C%D1%81%D1%8F-%D0%B2%D1%96%D0%B4-%D0%B7%D0%B2%D0%B8%D1%87%D0%B0%D0%B9%D0%BD%D0%B8%D1%85-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%96%D0%B2-%D0%B2-%D1%96%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0%D1%85)
### 4. Чому з лямбда-виразів неможна звертатись до локальних змінних, що змінюють свої значення?
  - ![захват змінних](https://github.com/nicknema/essentials-Of-Programming/blob/master/QAsem2Lab8.md#8-%D1%87%D0%BE%D0%BC%D1%83-%D0%B7-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D1%85-%D1%82%D0%B0-%D0%B0%D0%BD%D0%BE%D0%BD%D1%96%D0%BC%D0%BD%D0%B8%D1%85-%D0%BA%D0%BB%D0%B0%D1%81%D1%96%D0%B2-%D0%BD%D0%B5%D0%BC%D0%BE%D0%B6%D0%BD%D0%B0-%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%8C-%D0%B4%D0%BE-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B8%D1%85-%D0%B7%D0%BC%D1%96%D0%BD%D0%BD%D0%B8%D1%85-%D1%89%D0%BE-%D0%B7%D0%BC%D1%96%D0%BD%D1%8E%D1%8E%D1%82%D1%8C-%D1%81%D0%B2%D0%BE%D1%97-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F)
### 5. В чому полягає різниця між поняттями «final» та «effectively final»?
  - ![«final» та «effectively final»](https://github.com/nicknema/essentials-Of-Programming/blob/master/QAsem2Lab8.md#9-%D0%B2-%D1%87%D0%BE%D0%BC%D1%83-%D0%BF%D0%BE%D0%BB%D1%8F%D0%B3%D0%B0%D1%94-%D1%80%D1%96%D0%B7%D0%BD%D0%B8%D1%86%D1%8F-%D0%BC%D1%96%D0%B6-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D1%82%D1%8F%D0%BC%D0%B8-final-%D1%82%D0%B0-effectively-final)
### 6. В яких випадках використовується інтерфейс Consumer?
  - The lambda expression assigned to an object of Consumer type is used to define its accept() which eventually applies the given operation on its argument. Consumers are useful when it not needed to return any value as they are expected to operate via side-effects. 
  ```java
  // Consumer to multiply 2 to every integer of a list 
  Consumer<List<Integer> > modify = list -> 
  { 
      for (int i = 0; i < list.size(); i++) 
          list.set(i, 2 * list.get(i)); 
  }; 

  // Consumer to display a list of numbers 
  Consumer<List<Integer> > 
      dispList = list -> list.stream().forEach(a -> System.out.print(a + " ")); 
  ```
### 7. Поясніть різницю між <? super T> та <? extends T>. В яких випадках слід застосовувати <? super T>, <? extends T>, а в яких просто <T> без super або extends?
  The principles behind this in computer science is called :
    - Covariance: ? extends MyClass,
    - Contravariance: ? super MyClass and
    - Invariance/non-variance: MyClass

  ![contravariance and covariance](https://i.stack.imgur.com/KjDLw.png)
  
# Case 1: You want to go through the collection and do things with each item.
Then the list is a producer, so you should use a Collection`<? extends Thing>`.

The reasoning is that a `Collection<? extends Thing>` could hold any subtype of `Thing`, and thus each element will behave as a `Thing` when you perform your operation. (You actually cannot add anything to a `Collection<? extends Thing>`, because you cannot know at runtime which specific subtype of `Thing` the collection holds.)

# Case 2: You want to add things to the collection.
Then the list is a consumer, so you should use a `Collection<? super Thing>`.

The reasoning here is that unlike `Collection<? extends Thing>`, `Collection<? super Thing>` can always hold a Thing no matter what the actual parameterized type is. Here you don't care what is already in the list as long as it will allow a `Thing` to be added; this is what `? super Thing` guarantees.

Liskov substitution principle: if S is a subtype of T, then objects of type T may be replaced with objects of type S.

Within the type system of a programming language, a typing rule
   - covariant if it preserves the ordering of types (≤), which orders types from more specific to more generic;
   - contravariant if it reverses this ordering;
   - invariant or nonvariant if neither of these applies.

Covariance and contravariance
   - Read-only data types (sources) can be covariant;
   - write-only data types (sinks) can be contravariant.
   - Mutable data types which act as both sources and sinks should be invariant.

To illustrate this general phenomenon, consider the array type. For the type Animal we can make the type Animal[]
   - covariant: a Cat[] is an Animal[];
   - contravariant: an Animal[] is a Cat[];
   - invariant: an Animal[] is not a Cat[] and a Cat[] is not an Animal[].
[you can find more on the source](https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super)
