
  1. Чим процес відрізняється від треда?

     Процесс (задача) - программа, находящаяся в режиме выполнения.
С каждым процессом связывается его адресное пространство, из которого он может читать
и в которое он может писать данные.
Адресное пространство содержит:
  - саму программу
  - данные к программе
  - стек программы

С каждым процессом связывается набор регистров,например:
  - счетчика команд (в процессоре) - регистр в котором содержится адрес следующей,
  стоящей в очереди на выполнение команды. После того как команда выбрана из памяти, 
  счетчик команд корректируется и указатель переходит к следующей команде.
  - указатель стека

     С каждым потоком связывается:
  - Счетчик выполнения команд
  - Регистры для текущих переменных
  - Стек
  - Состояние 

Потоки делят между собой элементы своего процесса:
  - Адресное пространство
  - Глобальные переменные
  - Открытые файлы
  - Таймеры
  - Семафоры
  - Статистическую информацию.



  Process - процесс обладает автономной средой выполнения.

      Каждый процесс, в частности, имеет собственную область памяти.
      Процесс обычно воспринимается, как синоним выполнению программы или приложения. 
      Однако бывает, что одна приложения занимает несколько процессов.
      Большинство реализаций JVM запускаются в едином процессе.
      Java приложение может создать дополнительный процесс с помощью ProcessBuilder объекта.

  Thread - потоки иногда называют легковесными процессами (lightweight processes). 
  Потоки существуют внутри процесса - каждый процесс обладает хотя бы одним потоком.

      Потоки делят ресурсы процесса, включая память и открытые файлы.
      Приложение может быть как однопоточным, так и многопоточным, но всегда существует 
      единственный "главный" поток, с которого запускается приложение.

• 1 Running program (instance) = 1..N processes
• 1 process = 1..N threads


  2. В чому полягає різниця між кооперативною та витискальною багатозадачністю? 
  Яка з цих моделей реалізована у Java?

    - Вытесняющая многозадачность дословно прерывающая/замещающая  — это вид многозадачности, 
     при которой операционная система принимает решение о переключении между задачами по истечении
     некоего кванта времени
    Решение принимается в соответствии с приоритетами задач. В отличие от кооперативной многозадачности,
    управление операционной системе передаётся вне зависимости от состояния работающих приложений, 
    благодаря чему, в частности, зависшие (к примеру — зациклившиеся) приложения, как правило,
    не «подвешивают» операционную систему. За счёт регулярного переключения задач также улучшается
    отзывчивость системы, оперативность освобождения ресурсов системы, которые больше не используются задачей
    - Совместная или кооперативная многозадачность - Тип многозадачности, при котором следующая задача
    выполняется только после того, как текущая задача явно объявит себя готовой отдать процессорное время
    другим задачам. Как частный случай такое объявление подразумевается при попытке захвата уже занятого
    объекта мьютекс (ядро Linux), а также при ожидании поступления следующего сообщения от подсистемы пользовательского
    интерфейса (Windows версий до 3.x включительно, а также 16-битные приложения в Windows 9x). 
    - витісняюча
  3. Пояснити діаграму станів об’єкта класу Thread. Чим стан «Running» відрізняється від стану «Runnable»?
  ![diaghram](https://javarush.ru/images/article/76e73bfe-c9be-4ab6-9c9a-19e28d7f996d/original.jpeg)
  ![Image of Yaktocat](https://octodex.github.com/images/yaktocat.png)
  ![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png "Logo Title Text 1")
  https://javarush.ru/images/article/76e73bfe-c9be-4ab6-9c9a-19e28d7f996d/original.jpeg
  4. Коли і як слід використовувати методи run() та start() класу Thread?    
  - start() - запускает данный поток из текущего потока.
      Этот метод вызывает run() метод этого же потока.
  - run() - наследники Thread должны перегружать данный метод. Он вызывается при старте потока.

    Thread.run() or Runnable.run()
    – override
    – never call
    Thread.start()
    – call
    – never override


  5. Чому не слід використовувати deprecated-методи класу Thread?

  6. Для чого потрібен метод join()?
  Join - позволяет одному потоку ждать окончание выполнения другого потока.
  join() - заставляет поток ждать не более чем указанное время, чтобы завершиться.
    Реализация данного метода использует цикл с вызовом wait(), который вызывается пока isAlive. 
    После завершения потока вызывается notifyAll() метод.
    Он создан для того, чтобы приложения не использовали методы wait(),notify,notifyAll методы
    из Thread сущностей, так как это не рекомендованно.
    Если не указывать время или указать 0, то поток будет ждать вечно чтобы умереть... пичаль.

